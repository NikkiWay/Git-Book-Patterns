---
description: Template Method
---

# Шаблонный метод

## Назначение

Паттерн шаблонный метод (Template Method) представляет из себя класс, который позволяет собирать метод из алгоритмов на основе этапов и варьировать каждый из этих алгоритмов.

При этом задачей самого шаблонного метода становится передача данных после выполнения определённого этапа на следующий этап.

## Решаемые задачи

* управление расширениями подклассов

{% hint style="info" %}
Можно определить шаблонный метод так, что он будет вызывать операции-зацепки (hooks) в определенных местах программы, разрешив тем самым расширение только в этих местах.
{% endhint %}

* избавление от дублирования кода методом вычленения и локализации в одном классе поведения, общего для всех подклассов

{% hint style="info" %}
Сначала идентифицируются различия в существующем коде, а затем они выносятся в отдельные операции (методы или функции). В конечном итоге различающиеся фрагменты кода заменяются шаблонным методом, из которого вызываются новые операции.
{% endhint %}

* необходимость использовать одни и те же части алгоритма повторно, оставляя возможность изменять специфическое поведение в разных подклассах

## Общая реализация на языке С++

{% tabs %}
{% tab title="includes" %}
{% code lineNumbers="true" fullWidth="true" %}
```cpp
#include <iostream>

using namespace std;
```
{% endcode %}
{% endtab %}

{% tab title="AbstractClass" %}
{% code lineNumbers="true" fullWidth="true" %}
```cpp
class AbstractClass
{
public:
    void templateMethod()
    {
        primitiveOperation();
        concreteOperation();
        hook();
    }
    virtual ~AbstractClass() = default;
protected:
    virtual void primitiveOperation() = 0;
    void concreteOperation() 
    { 
        cout << "concreteOperation;" << endl; 
    }
    virtual void hook() 
    { 
        cout << "hook Base;" << endl; 
    }
};
```
{% endcode %}
{% endtab %}

{% tab title="ConcreteClassA" %}
{% code lineNumbers="true" fullWidth="true" %}
```cpp
class ConcreteClassA : public AbstractClass
{
protected:
    void primitiveOperation() override 
    { 
        cout << "primitiveOperation A;" << endl; 
    }
};
```
{% endcode %}
{% endtab %}

{% tab title="ConcreteClassB" %}
{% code lineNumbers="true" fullWidth="true" %}
```cpp
class ConcreteClassB : public AbstractClass
{
protected:
    void primitiveOperation() override 
    { 
        cout << "primitiveOperation B;" << endl; 
    }
    void hook() override 
    { 
        cout << "hook B;" << endl; 
    }
};
```
{% endcode %}
{% endtab %}
{% endtabs %}

{% code lineNumbers="true" fullWidth="true" %}
```cpp
int main()
{
    ConcreteClassA ca;
    ConcreteClassB cb;

    ca.templateMethod();
    cb.templateMethod();
}
```
{% endcode %}

## Преимущества

* позволяет избежать дублирования кода
* облегчается замена алгоритмов и методов без внесения изменений в основную структуру кода
* упрощается понимание и поддержка кода за счет разделения алгоритмов на более мелкие этапы
* возможность управления расширениями подклассов

## Недостатки

* внесение изменений в общую структуру алгоритма может потребовать соответствующих изменений во всех подклассах.
* при значительном увеличении числа этапов алгоритма класс может стать слишком сложным и трудным для поддержки и понимания
* множественные шаги алгоритма, каждый из которых требует изменений в отдельном подклассе, могут привести к созданию большого количества классов-наследников

## Связь с другими паттернами

* [Фабричный метод](../creationals-patterns/factory-method.md): часто вызывается из шаблонных методах.
* [Стратегия](strategy.md): шаблонные методы применяют наследование для модификации части алгоритма. Стратегии используют делегирование для модификации алгоритма в целом.
* [Декоратор](../structural-patterns/dekorator.md): шаблонный метод может быть использован вместе с паттерном декоратор для добавления дополнительного поведения внутри шагов алгоритма. Декораторы могут быть применены к определенным шагам алгоритма, чтобы модифицировать их поведение без изменения самого шаблона метода.
* [Цепочка обязанностей](chain-of-responsibility.md): шаблонный метод может быть частью цепочки обязанностей, где каждый шаг алгоритма представляет отдельное звено в цепочке. Цепочка обязанностей позволяет разделить обработку запросов на разные уровни и динамически определить, какой шаг должен обработать конкретный запрос.
