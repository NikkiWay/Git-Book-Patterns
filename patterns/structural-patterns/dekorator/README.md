---
description: Decorator
layout:
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Декоратор

## Проблема

При добавлении одинакового кода в разные классы иерархии возникают проблемы ее разрастания и дублирования кода. Для решения сформировалась идея вынесения общего кода в отдельный класс, имеющий такой же интерфейс и содержащий указатель на базовый компонент.

## Назначение

Декоратор - это класс, который оборачивает исходный объект (декорируемый объект). Он наследуется от того же интерфейса, что и декорируемый объект, и делегирует вызовы методов исходному объекту, добавляя свою собственную функциональность до или после вызова. Паттерн декоратор (Decorator) позволяет динамически добавлять новые обязанности объекту. Декораторы являются гибкой альтернативой порождению подклассов для расширения функциональности. Рекурсивно декорирует основной объект.

Предполагает возможность применять несколько декораторов последовательно, оборачивая один декоратор в другой. Каждый декоратор добавляет свою функциональность к объекту, а затем передает управление следующему декоратору в цепочке, пока не достигнет последнего. Паттерн декоратор использует схему "обертываем подарок, кладем его в коробку, обертываем коробку"

## Решаемые задачи

* Расширение функциональности без изменения исходного кода

Декоратор позволяет динамически добавлять к объекту новую функциональность, не изменяя его исходный код. Это полезно, когда необходимо добавить поведение во время выполнения программы или без нарушения принципа единственной ответственности.

* Уменьшение дублирования кода

Паттерн Декоратор помогает уменьшить дублирование кода, так как общая функциональность может быть реализована в отдельных декораторах, которые затем можно повторно использовать.

* Повышение гибкости и расширяемости

Декораторы повышают гибкость и расширяемость кодовой базы, позволяя легко добавлять или удалять функциональность без необходимости изменять другие части системы.

* Разделение ответственности

Декораторы помогают разделить функциональность на более мелкие модули, делая код более понятным и управляемым.

## UML диаграмма

<div data-full-width="true">

<figure><img src="../../../.gitbook/assets/decorator_white.png" alt=""><figcaption><p>UML диаграмма паттерна "Декоратор"</p></figcaption></figure>

</div>

* Component - интерфейс как объектов декорируемых классов (ConcreteComponent1, ... ConcreteComponentN) так и самого декоратора.
* Decorator - класс, который предоставляет рекурсивную надстройку над исходным интерфейсом (Component) собственным производным (ConcreteDecorator1, ... ConcreteDecoratorN)



## Преимущества

* Можно изменять поведение(декорировать) и принимать решения на этапе выполнения программы
* Не разрастается иерархия
* Уходим от дублирования кода
* Позволяет избежать перегруженных функциями классов на верхних уровнях иерархии
* Гибкость, то есть возможность добавлять желаемую реализацию к любому классу. Появлется возможность "декорировать" декораторы

## Недостатки

* Все основано на полиморфизме

Происходит «лавинная» цепочка вызовов: нужно пройти через множество виртуальных таблиц, чтобы добраться до того, что нужно. Из-за этого снижается скорость выполнения.

* Для того чтобы создать объект, который будет обернут множеством декораторов, нужно создать очень умный creator, который будет создавать такой объект. Из-за этого контроль переходит на уровень программиста
* Если нужно изъять какой-то декоратор из цепочки, нужно заново декорировать объект.
* Контроль переходит к программисту

Например, важен порядок декорирования, а его задает программист.

## Примеры использования паттерна Декоратор

* Добавление новых функций к объектам

Например, к объекту автомобиля можно добавить функции, такие как круиз-контроль, парктроник или подогрев сидений с помощью декораторов.

* Изменение внешнего вида объектов

Декораторы можно использовать для изменения внешнего вида объектов, например, для добавления рамок или теней к изображениям или для отображения текста разным шрифтом.

* Реализация доступа к данным на основе ролей

Декораторы можно использовать для реализации доступа к данным на основе ролей, путем добавления ограничений на доступ к объектам в зависимости от роли пользователя.

* Кеширование и оптимизация производительности

Декораторы могут быть использованы для кеширования результатов и повышения производительности путем запоминания и повторного использования предыдущих вычислений.

* Ведение логов и отслеживание

Декораторы могут быть использованы для ведения логов и отслеживания вызовов определенных методов, что может быть полезно для отладки и анализа производительности.

В целом, паттерн проектирования Декоратор предоставляет мощный и гибкий способ расширять поведение объектов динамически и неинтрузивно, повышая гибкость, расширяемость и модульность кодовой базы.



## Связь с другими паттернами

* [Компоновщик](../composite/): декоратор можно рассматривать как вырожденный случай компоновщика с единственным компонентом. Однако Decorator добавляет новые обязанности и не предназначен для агрегирования объектов.
* [Стратегия](../../behavioral-patterns/strategy/): декоратор хорошо совмещается с паттерном стратегия. Декоратор позволяет изменить внешний облик объекта, стратегия – его внутреннее содержание. Это два взаимодополняющих способа изменения объекта.
* [Адаптер](https://github.com/NikkiWay/Git-Book-Patterns/blob/main/patterns/structural-patterns/adapter.md): если декоратор изменяет только обязанности объекта, но не его интерфейс, то адаптер придает объекту совершенно новый интерфейс.
*   [Заместитель](../proxy/) и Декоаратор имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что _Заместитель_ сам управляет жизнью сервисного объекта, а обёртывание _Декораторов_ контролируется клиентом.

